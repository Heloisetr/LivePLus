{"ast":null,"code":"function splitFileData(data, length) {\n  let table = new Array(length * length);\n  table.fill(false);\n  const tmpTable = data.split(\";\");\n  console.log(tmpTable);\n\n  for (let index = 0; index < tmpTable.length; index++) {\n    const tmpCoord = tmpTable[index].split(\",\");\n    table[length * Number(tmpCoord[1]) + Number(tmpCoord[0])] = true;\n  }\n\n  return table;\n}\n\nexport function calculateActiveCells(data) {\n  const splitData = data.split(\"\\n\");\n  const mapLength = Number(splitData[0]);\n  const fileCoordinates = splitFileData(splitData[1], mapLength);\n  return {\n    mapLength,\n    fileCoordinates\n  };\n}\n\nfunction calculateCell(coordData, index) {\n  let countAlive = 0;\n  const length = coordData.mapLength;\n\n  if (index % length !== 0 && coordData.coordinates[index - 1]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index % (length - 1) !== 0 && coordData.coordinates[index + 1]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index >= length && coordData.coordinates[index - length]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index <= length * (length - 1) && coordData.coordinates[index + length]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index % length !== 0 && index >= length && coordData.coordinates[index - (1 + length)]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index % (length - 1) !== 0 && index >= length && coordData.coordinates[index - (length - 1)]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index % length !== 0 && index <= length * (length - 1) && coordData.coordinates[index + (length - 1)]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index % (length - 1) !== 0 && index <= length * (length - 1) && coordData.coordinates[index + (1 + length)]) {\n    countAlive = countAlive + 1;\n  }\n\n  console.log(index);\n\n  switch (coordData.coordinates[index]) {\n    case true:\n      return countAlive === 2 || countAlive === 3 ? true : false;\n\n    case false:\n      return countAlive === 3 ? true : false;\n\n    default:\n      return false;\n  }\n}\n\nexport function modifyCells(coordData) {\n  const table = [];\n  const coord = coordData.coordinates;\n  coord.map((cell, index) => {\n    table.push(calculateCell(coordData, index));\n  });\n  console.log(table);\n  return table;\n}\nexport function updateExportFile(coordData) {\n  const fs = require('fs');\n\n  let path = './export.txt';\n  let buffer = new Buffer('TEstTEstt ');\n  fs.open(path, 'w', function (err, fd) {\n    if (err) {\n      throw 'could not open file: ' + err;\n    }\n\n    fs.write(fd, buffer, 0, buffer.length, null, function (err) {\n      if (err) throw 'error writing file: ' + err;\n      fs.close(fd, function () {\n        console.log('wrote the file successfully');\n      });\n    });\n  });\n}","map":{"version":3,"sources":["/Users/heloisetronche/dev/Internship_test/LivePlus/src/utils/calculateActiveCells.ts"],"names":["splitFileData","data","length","table","Array","fill","tmpTable","split","console","log","index","tmpCoord","Number","calculateActiveCells","splitData","mapLength","fileCoordinates","calculateCell","coordData","countAlive","coordinates","modifyCells","coord","map","cell","push","updateExportFile","fs","require","path","buffer","Buffer","open","err","fd","write","close"],"mappings":"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","sourcesContent":["import { CoordinatesContentType } from \"types/CoordinatesType\";\n\nfunction splitFileData(data: string, length: number): boolean[] {\n  let table: boolean[] = new Array(length*length);\n  table.fill(false);\n  \n  const tmpTable = data.split(\";\");\n\n  console.log(tmpTable);\n\n  for (let index = 0; index < tmpTable.length; index++) {\n    const tmpCoord = tmpTable[index].split(\",\");\n\n    table[(length * Number(tmpCoord[1])) + Number(tmpCoord[0])] = true;\n  }\n  \n  return table;\n}\n\nexport function calculateActiveCells(data: string): {mapLength: number, fileCoordinates: boolean[] } {\n  const splitData = data.split(\"\\n\");\n  const mapLength =  Number(splitData[0]);\n  \n  const fileCoordinates = splitFileData(splitData[1], mapLength);\n  \n  return { mapLength, fileCoordinates }\n}\n\n\nfunction calculateCell(coordData: CoordinatesContentType, index: number): boolean {\n  let countAlive = 0;\n\n  const length = coordData.mapLength;\n  \n  if ((index % length) !== 0 && coordData.coordinates[index - 1]) {\n    countAlive = countAlive + 1;\n  }\n  if ((index % (length - 1)) !== 0 && coordData.coordinates[index + 1]) {\n    countAlive = countAlive + 1;\n  }\n  if (index >= length && coordData.coordinates[index - length]) {\n    countAlive = countAlive + 1;\n  }\n  if (index <= (length * (length - 1)) && coordData.coordinates[index + length]) {\n    countAlive = countAlive + 1;\n  }\n  if ((index % length) !== 0 && index >= length && coordData.coordinates[index - (1 + length)]) {\n    countAlive = countAlive + 1;\n  }\n  if ((index % (length - 1)) !== 0 && index >= length && coordData.coordinates[index - (length - 1)]) {\n    countAlive = countAlive + 1;\n  }\n  if ((index % length) !== 0 && index <= (length * (length - 1)) && coordData.coordinates[index + (length - 1)]) {\n    countAlive = countAlive + 1;\n  }\n  if ((index % (length - 1)) !== 0 && index <= (length * (length - 1)) && coordData.coordinates[index + (1 + length)]) {\n    countAlive = countAlive + 1;\n  }\n\n\n  console.log(index);\n  switch(coordData.coordinates[index]) {\n    case true:\n      return ((countAlive === 2 || countAlive === 3) ? true : false);\n\n    case false:\n      return (countAlive === 3 ? true : false);\n\n    default:\n      return false;\n  }\n}\n\nexport function modifyCells(coordData: CoordinatesContentType): boolean[] {\n  const table: boolean[]= [];\n  const coord = coordData.coordinates;\n\n  coord.map((cell, index) => {\n    table.push(calculateCell(coordData, index));\n  });\n\n  console.log(table);\n  return table;\n}\n\nexport function updateExportFile(coordData: CoordinatesContentType): void {\n  const fs = require('fs');\n\n  let path = './export.txt';\n  let buffer = new Buffer('TEstTEstt ');\n\n  fs.open(path, 'w', function(err: any, fd: any) {\n    if (err) {\n      throw 'could not open file: ' + err;\n    }\n\n    fs.write(fd, buffer, 0, buffer.length, null, function(err: any) {\n      if (err) throw 'error writing file: ' + err;\n      fs.close(fd, function() {\n        console.log('wrote the file successfully');\n      });\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module"}