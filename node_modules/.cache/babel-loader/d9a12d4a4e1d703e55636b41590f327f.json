{"ast":null,"code":"function splitFileData(data, length) {\n  let table = new Array(length * length);\n  table.fill(false);\n  const tmpTable = data.split(\";\");\n\n  for (let index = 0; index < tmpTable.length; index++) {\n    const tmpCoord = tmpTable[index].split(\",\");\n    table[length * Number(tmpCoord[1]) + Number(tmpCoord[0])] = true;\n  }\n\n  return table;\n}\n\nexport function calculateActiveCells(data) {\n  const splitData = data.split(\"\\n\");\n  const mapLength = Number(splitData[0]);\n  const fileCoordinates = splitFileData(splitData[1], mapLength);\n  return {\n    mapLength,\n    fileCoordinates\n  };\n}\n\nfunction calculateCell(coordData, index) {\n  let countAlive = 0;\n  const length = coordData.mapLength;\n\n  if (index % length !== 0 && coordData.coordinates[index - 1]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index % (length - 1) !== 0 && coordData.coordinates[index + 1]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index >= length && coordData.coordinates[index - length]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index <= length * (length - 1) && coordData.coordinates[index + length]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index % length !== 0 && index >= length && coordData.coordinates[index - (1 + length)]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index % (length - 1) !== 0 && index >= length && coordData.coordinates[index - (length - 1)]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index % length !== 0 && index <= length * (length - 1) && coordData.coordinates[index + (length - 1)]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index % (length - 1) !== 0 && index <= length * (length - 1) && coordData.coordinates[index + (1 + length)]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index === 0) {\n    console.log(index);\n    console.log(index - 1);\n    console.log(index + 1);\n    console.log(index - length);\n    console.log(index + length);\n    console.log(index - (1 + length));\n    console.log(index - (length - 1));\n    console.log(index + (length - 1));\n    console.log(index + (length + 1));\n  }\n  /*switch(coordData.coordinates[index]) {\n    case true:\n      return ((countAlive === 2 || countAlive === 3) ? true : false);\n     case false:\n      return (countAlive === 3 ? true : false);\n     default:\n      return false;\n  }*/\n\n\n  switch (countAlive) {\n    case 2:\n      return coordData.coordinates[index] ? true : false;\n\n    case 3:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexport function modifyCells(coordData) {\n  const table = [];\n  const coord = coordData.coordinates;\n  coord.map((cell, index) => {\n    table.push(calculateCell(coordData, index));\n    return null;\n  });\n  return table;\n}\nexport function convertToDataBrut(coordinates, mapLength) {\n  const tmp = [];\n  coordinates.map((cell, index) => {\n    if (cell === true) {\n      tmp.push(String(Math.floor(index % mapLength)) + \",\" + String(Math.floor(index / mapLength)));\n    }\n\n    return null;\n  });\n  return tmp.join(';');\n}","map":{"version":3,"sources":["/Users/heloisetronche/dev/Internship_test/LivePlus/src/utils/calculateActiveCells.ts"],"names":["splitFileData","data","length","table","Array","fill","tmpTable","split","index","tmpCoord","Number","calculateActiveCells","splitData","mapLength","fileCoordinates","calculateCell","coordData","countAlive","coordinates","console","log","modifyCells","coord","map","cell","push","convertToDataBrut","tmp","String","Math","floor","join"],"mappings":"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","sourcesContent":["import { CoordinatesContentType } from \"types/CoordinatesType\";\n\nfunction splitFileData(data: string, length: number): boolean[] {\n  let table: boolean[] = new Array(length*length);\n  table.fill(false);\n  \n  const tmpTable = data.split(\";\");\n\n  for (let index = 0; index < tmpTable.length; index++) {\n    const tmpCoord = tmpTable[index].split(\",\");\n\n    table[(length * Number(tmpCoord[1])) + Number(tmpCoord[0])] = true;\n  }\n  \n  return table;\n}\n\nexport function calculateActiveCells(data: string): {mapLength: number, fileCoordinates: boolean[] } {\n  const splitData = data.split(\"\\n\");\n  const mapLength =  Number(splitData[0]);\n  \n  const fileCoordinates = splitFileData(splitData[1], mapLength);\n  \n  return { mapLength, fileCoordinates }\n}\n\n\nfunction calculateCell(coordData: CoordinatesContentType, index: number): boolean {\n  let countAlive = 0;\n\n  const length = coordData.mapLength;\n  \n  if ((index % length) !== 0 && coordData.coordinates[index - 1]) {\n    countAlive = countAlive + 1;\n  }\n  if ((index % (length - 1)) !== 0 && coordData.coordinates[index + 1]) {\n    countAlive = countAlive + 1;\n  }\n  if (index >= length && coordData.coordinates[index - length]) {\n    countAlive = countAlive + 1;\n  }\n  if (index <= (length * (length - 1)) && coordData.coordinates[index + length]) {\n    countAlive = countAlive + 1;\n  }\n  if ((index % length) !== 0 && index >= length && coordData.coordinates[index - (1 + length)]) {\n    countAlive = countAlive + 1;\n  }\n  if ((index % (length - 1)) !== 0 && index >= length && coordData.coordinates[index - (length - 1)]) {\n    countAlive = countAlive + 1;\n  }\n  if ((index % length) !== 0 && index <= (length * (length - 1)) && coordData.coordinates[index + (length - 1)]) {\n    countAlive = countAlive + 1;\n  }\n  if ((index % (length - 1)) !== 0 && index <= (length * (length - 1)) && coordData.coordinates[index + (1 + length)]) {\n    countAlive = countAlive + 1;\n  }\n\n  if (index === 0) {\n    console.log(index);\n    console.log(index - 1);\n    console.log(index + 1);\n    console.log(index - length);\n    console.log(index + length);\n    console.log(index - (1 + length));\n    console.log(index - (length - 1));\n    console.log(index + (length - 1));\n    console.log(index + (length + 1));\n  }\n\n  /*switch(coordData.coordinates[index]) {\n    case true:\n      return ((countAlive === 2 || countAlive === 3) ? true : false);\n\n    case false:\n      return (countAlive === 3 ? true : false);\n\n    default:\n      return false;\n  }*/\n  switch(countAlive) {\n    case 2:\n      return (coordData.coordinates[index]) ? true : false;\n\n    case 3:\n      return true;\n    \n    default:\n      return false;\n  }\n}\n\nexport function modifyCells(coordData: CoordinatesContentType): boolean[] {\n  const table: boolean[]= [];\n  const coord = coordData.coordinates;\n\n  coord.map((cell, index) => {\n    table.push(calculateCell(coordData, index));\n    return null;\n  });\n\n  return table;\n}\n\nexport function convertToDataBrut(coordinates: boolean[], mapLength: number): string {\n  const tmp: string[] = [];\n\n\n  coordinates.map((cell, index) => {\n    if (cell === true) {\n      tmp.push(String(Math.floor(index % mapLength)) + \",\" + String(Math.floor(index / mapLength)));\n    }\n    return null;\n  });\n\n  return tmp.join(';');\n}\n"]},"metadata":{},"sourceType":"module"}